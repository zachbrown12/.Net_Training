/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import { Directive, Input, ElementRef, Optional, ChangeDetectorRef } from '@angular/core';
import { Subject } from 'rxjs';
import { filter } from 'rxjs/operators';
import { TimeagoClock } from './timeago.clock';
import { TimeagoFormatter } from './timeago.formatter';
import { TimeagoIntl } from './timeago.intl';
import { isDefined, coerceBooleanProperty, dateParser } from './util';
export class TimeagoDirective {
    /**
     * @param {?} intl
     * @param {?} cd
     * @param {?} formatter
     * @param {?} element
     * @param {?} clock
     */
    constructor(intl, cd, formatter, element, clock) {
        this.cd = cd;
        this.clock = clock;
        /**
         * Emits on:
         * - Input change
         * - Intl change
         * - Clock tick
         */
        this.stateChanges = new Subject();
        this._live = true;
        if (intl) {
            this.intlSubscription = intl.changes.subscribe(() => this.stateChanges.next());
        }
        this.stateChanges.subscribe(() => {
            this.setContent(element.nativeElement, formatter.format(this.date));
            this.cd.markForCheck();
        });
    }
    /**
     * The Date to display. An actual Date object or something that can be fed to new Date.
     * @return {?}
     */
    get date() {
        return this._date;
    }
    /**
     * @param {?} date
     * @return {?}
     */
    set date(date) {
        this._date = dateParser(date).valueOf();
        if (this._date) {
            if (this.clockSubscription) {
                this.clockSubscription.unsubscribe();
                this.clockSubscription = undefined;
            }
            this.clockSubscription = this.clock.tick(this.date)
                .pipe(filter(() => this.live, this))
                .subscribe(() => this.stateChanges.next());
        }
        else {
            throw new SyntaxError(`Wrong parameter in TimeagoDirective. Expected a valid date, received: ${date}`);
        }
    }
    /**
     * If the directive should update itself over time
     * @return {?}
     */
    get live() {
        return this._live;
    }
    /**
     * @param {?} live
     * @return {?}
     */
    set live(live) {
        this._live = coerceBooleanProperty(live);
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        this.stateChanges.next();
    }
    /**
     * @param {?} node
     * @param {?} content
     * @return {?}
     */
    setContent(node, content) {
        if (isDefined(node.textContent)) {
            node.textContent = content;
        }
        else {
            node.data = content;
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.intlSubscription) {
            this.intlSubscription.unsubscribe();
            this.intlSubscription = undefined;
        }
        if (this.clockSubscription) {
            this.clockSubscription.unsubscribe();
            this.clockSubscription = undefined;
        }
        this.stateChanges.complete();
    }
}
TimeagoDirective.decorators = [
    { type: Directive, args: [{
                selector: '[timeago]',
                exportAs: 'timeago',
            },] },
];
/** @nocollapse */
TimeagoDirective.ctorParameters = () => [
    { type: TimeagoIntl, decorators: [{ type: Optional }] },
    { type: ChangeDetectorRef },
    { type: TimeagoFormatter },
    { type: ElementRef },
    { type: TimeagoClock }
];
TimeagoDirective.propDecorators = {
    date: [{ type: Input }],
    live: [{ type: Input }]
};
function TimeagoDirective_tsickle_Closure_declarations() {
    /** @type {?} */
    TimeagoDirective.prototype.intlSubscription;
    /** @type {?} */
    TimeagoDirective.prototype.clockSubscription;
    /**
     * Emits on:
     * - Input change
     * - Intl change
     * - Clock tick
     * @type {?}
     */
    TimeagoDirective.prototype.stateChanges;
    /** @type {?} */
    TimeagoDirective.prototype._date;
    /** @type {?} */
    TimeagoDirective.prototype._live;
    /** @type {?} */
    TimeagoDirective.prototype.cd;
    /** @type {?} */
    TimeagoDirective.prototype.clock;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGltZWFnby5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZ3gtdGltZWFnby8iLCJzb3VyY2VzIjpbInRpbWVhZ28uZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxVQUFVLEVBQUUsUUFBUSxFQUF3QixpQkFBaUIsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNoSCxPQUFPLEVBQWdCLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUM3QyxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDeEMsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQy9DLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQ3ZELE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUM3QyxPQUFPLEVBQUUsU0FBUyxFQUFFLHFCQUFxQixFQUFFLFVBQVUsRUFBRSxNQUFNLFFBQVEsQ0FBQztBQU10RSxNQUFNOzs7Ozs7OztJQTJDSixZQUF3QixJQUFpQixFQUNyQixJQUNSLFNBQTJCLEVBQzNCLE9BQW1CLEVBQ1g7UUFIQSxPQUFFLEdBQUYsRUFBRTtRQUdGLFVBQUssR0FBTCxLQUFLOzs7Ozs7OzRCQXJDVixJQUFJLE9BQU8sRUFBTztxQkErQmpCLElBQUk7UUFPbEIsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztZQUNULElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksRUFBRSxDQUFDLENBQUM7U0FDaEY7UUFDRCxJQUFJLENBQUMsWUFBWSxDQUFDLFNBQVMsQ0FBQyxHQUFHLEVBQUU7WUFDL0IsSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsYUFBYSxFQUFFLFNBQVMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7WUFDcEUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxZQUFZLEVBQUUsQ0FBQztTQUN4QixDQUFDLENBQUM7S0FDSjs7Ozs7SUExQ0QsSUFDSSxJQUFJO1FBQ04sTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUM7S0FDbkI7Ozs7O0lBQ0QsSUFBSSxJQUFJLENBQUMsSUFBUztRQUNoQixJQUFJLENBQUMsS0FBSyxHQUFHLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUN4QyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztZQUNmLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUM7Z0JBQzNCLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxXQUFXLEVBQUUsQ0FBQztnQkFDckMsSUFBSSxDQUFDLGlCQUFpQixHQUFHLFNBQVMsQ0FBQzthQUNwQztZQUNELElBQUksQ0FBQyxpQkFBaUIsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO2lCQUNoRCxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7aUJBQ25DLFNBQVMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksRUFBRSxDQUFDLENBQUM7U0FDOUM7UUFBQyxJQUFJLENBQUMsQ0FBQztZQUNOLE1BQU0sSUFBSSxXQUFXLENBQUMseUVBQXlFLElBQUksRUFBRSxDQUFDLENBQUM7U0FDeEc7S0FDRjs7Ozs7SUFJRCxJQUNJLElBQUk7UUFDTixNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQztLQUNuQjs7Ozs7SUFDRCxJQUFJLElBQUksQ0FBQyxJQUFhO1FBQ3BCLElBQUksQ0FBQyxLQUFLLEdBQUcscUJBQXFCLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDMUM7Ozs7SUFpQkQsV0FBVztRQUNULElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxFQUFFLENBQUM7S0FDMUI7Ozs7OztJQUVELFVBQVUsQ0FBQyxJQUFTLEVBQUUsT0FBZTtRQUNuQyxFQUFFLENBQUMsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNoQyxJQUFJLENBQUMsV0FBVyxHQUFHLE9BQU8sQ0FBQztTQUM1QjtRQUFDLElBQUksQ0FBQyxDQUFDO1lBQ04sSUFBSSxDQUFDLElBQUksR0FBRyxPQUFPLENBQUM7U0FDckI7S0FDRjs7OztJQUVELFdBQVc7UUFDVCxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDO1lBQzFCLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxXQUFXLEVBQUUsQ0FBQztZQUNwQyxJQUFJLENBQUMsZ0JBQWdCLEdBQUcsU0FBUyxDQUFDO1NBQ25DO1FBQ0QsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUMsQ0FBQztZQUMzQixJQUFJLENBQUMsaUJBQWlCLENBQUMsV0FBVyxFQUFFLENBQUM7WUFDckMsSUFBSSxDQUFDLGlCQUFpQixHQUFHLFNBQVMsQ0FBQztTQUNwQztRQUNELElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxFQUFFLENBQUM7S0FDOUI7OztZQW5GRixTQUFTLFNBQUM7Z0JBQ1QsUUFBUSxFQUFFLFdBQVc7Z0JBQ3JCLFFBQVEsRUFBRSxTQUFTO2FBQ3BCOzs7O1lBTlEsV0FBVyx1QkFrREwsUUFBUTtZQXZEZ0QsaUJBQWlCO1lBSS9FLGdCQUFnQjtZQUpFLFVBQVU7WUFHNUIsWUFBWTs7O21CQXNCbEIsS0FBSzttQkFxQkwsS0FBSyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERpcmVjdGl2ZSwgSW5wdXQsIEVsZW1lbnRSZWYsIE9wdGlvbmFsLCBPbkNoYW5nZXMsIE9uRGVzdHJveSwgQ2hhbmdlRGV0ZWN0b3JSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiwgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgZmlsdGVyIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgVGltZWFnb0Nsb2NrIH0gZnJvbSAnLi90aW1lYWdvLmNsb2NrJztcbmltcG9ydCB7IFRpbWVhZ29Gb3JtYXR0ZXIgfSBmcm9tICcuL3RpbWVhZ28uZm9ybWF0dGVyJztcbmltcG9ydCB7IFRpbWVhZ29JbnRsIH0gZnJvbSAnLi90aW1lYWdvLmludGwnO1xuaW1wb3J0IHsgaXNEZWZpbmVkLCBjb2VyY2VCb29sZWFuUHJvcGVydHksIGRhdGVQYXJzZXIgfSBmcm9tICcuL3V0aWwnO1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbdGltZWFnb10nLFxuICBleHBvcnRBczogJ3RpbWVhZ28nLFxufSlcbmV4cG9ydCBjbGFzcyBUaW1lYWdvRGlyZWN0aXZlIGltcGxlbWVudHMgT25DaGFuZ2VzLCBPbkRlc3Ryb3kge1xuICBwcml2YXRlIGludGxTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcbiAgcHJpdmF0ZSBjbG9ja1N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gIC8qKlxuICAgKiBFbWl0cyBvbjpcbiAgICogLSBJbnB1dCBjaGFuZ2VcbiAgICogLSBJbnRsIGNoYW5nZVxuICAgKiAtIENsb2NrIHRpY2tcbiAgKi9cbiAgc3RhdGVDaGFuZ2VzID0gbmV3IFN1YmplY3Q8YW55PigpO1xuXG4gIC8qKiBUaGUgRGF0ZSB0byBkaXNwbGF5LiBBbiBhY3R1YWwgRGF0ZSBvYmplY3Qgb3Igc29tZXRoaW5nIHRoYXQgY2FuIGJlIGZlZCB0byBuZXcgRGF0ZS4gKi9cbiAgQElucHV0KClcbiAgZ2V0IGRhdGUoKTogYW55IHtcbiAgICByZXR1cm4gdGhpcy5fZGF0ZTtcbiAgfVxuICBzZXQgZGF0ZShkYXRlOiBhbnkpIHtcbiAgICB0aGlzLl9kYXRlID0gZGF0ZVBhcnNlcihkYXRlKS52YWx1ZU9mKCk7XG4gICAgaWYgKHRoaXMuX2RhdGUpIHtcbiAgICAgIGlmICh0aGlzLmNsb2NrU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgIHRoaXMuY2xvY2tTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgdGhpcy5jbG9ja1N1YnNjcmlwdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2xvY2tTdWJzY3JpcHRpb24gPSB0aGlzLmNsb2NrLnRpY2sodGhpcy5kYXRlKVxuICAgICAgICAucGlwZShmaWx0ZXIoKCkgPT4gdGhpcy5saXZlLCB0aGlzKSlcbiAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLnN0YXRlQ2hhbmdlcy5uZXh0KCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFdyb25nIHBhcmFtZXRlciBpbiBUaW1lYWdvRGlyZWN0aXZlLiBFeHBlY3RlZCBhIHZhbGlkIGRhdGUsIHJlY2VpdmVkOiAke2RhdGV9YCk7XG4gICAgfVxuICB9XG4gIHByaXZhdGUgX2RhdGU6IG51bWJlcjtcblxuICAvKiogSWYgdGhlIGRpcmVjdGl2ZSBzaG91bGQgdXBkYXRlIGl0c2VsZiBvdmVyIHRpbWUgKi9cbiAgQElucHV0KClcbiAgZ2V0IGxpdmUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2xpdmU7XG4gIH1cbiAgc2V0IGxpdmUobGl2ZTogYm9vbGVhbikge1xuICAgIHRoaXMuX2xpdmUgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkobGl2ZSk7XG4gIH1cbiAgcHJpdmF0ZSBfbGl2ZSA9IHRydWU7XG5cbiAgY29uc3RydWN0b3IoQE9wdGlvbmFsKCkgaW50bDogVGltZWFnb0ludGwsXG4gICAgICAgICAgICAgIHByaXZhdGUgY2Q6IENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICAgICAgICBmb3JtYXR0ZXI6IFRpbWVhZ29Gb3JtYXR0ZXIsXG4gICAgICAgICAgICAgIGVsZW1lbnQ6IEVsZW1lbnRSZWYsXG4gICAgICAgICAgICAgIHByaXZhdGUgY2xvY2s6IFRpbWVhZ29DbG9jaykge1xuICAgIGlmIChpbnRsKSB7XG4gICAgICB0aGlzLmludGxTdWJzY3JpcHRpb24gPSBpbnRsLmNoYW5nZXMuc3Vic2NyaWJlKCgpID0+IHRoaXMuc3RhdGVDaGFuZ2VzLm5leHQoKSk7XG4gICAgfVxuICAgIHRoaXMuc3RhdGVDaGFuZ2VzLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICB0aGlzLnNldENvbnRlbnQoZWxlbWVudC5uYXRpdmVFbGVtZW50LCBmb3JtYXR0ZXIuZm9ybWF0KHRoaXMuZGF0ZSkpO1xuICAgICAgdGhpcy5jZC5tYXJrRm9yQ2hlY2soKTtcbiAgICB9KTtcbiAgfVxuXG4gIG5nT25DaGFuZ2VzKCkge1xuICAgIHRoaXMuc3RhdGVDaGFuZ2VzLm5leHQoKTtcbiAgfVxuXG4gIHNldENvbnRlbnQobm9kZTogYW55LCBjb250ZW50OiBzdHJpbmcpIHtcbiAgICBpZiAoaXNEZWZpbmVkKG5vZGUudGV4dENvbnRlbnQpKSB7XG4gICAgICBub2RlLnRleHRDb250ZW50ID0gY29udGVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5kYXRhID0gY29udGVudDtcbiAgICB9XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5pbnRsU3Vic2NyaXB0aW9uKSB7XG4gICAgICB0aGlzLmludGxTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgIHRoaXMuaW50bFN1YnNjcmlwdGlvbiA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKHRoaXMuY2xvY2tTdWJzY3JpcHRpb24pIHtcbiAgICAgIHRoaXMuY2xvY2tTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgIHRoaXMuY2xvY2tTdWJzY3JpcHRpb24gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHRoaXMuc3RhdGVDaGFuZ2VzLmNvbXBsZXRlKCk7XG4gIH1cbn1cbiJdfQ==