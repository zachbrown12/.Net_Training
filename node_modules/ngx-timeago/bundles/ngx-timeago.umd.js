(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('rxjs'), require('rxjs/operators')) :
    typeof define === 'function' && define.amd ? define('ngx-timeago', ['exports', '@angular/core', 'rxjs', 'rxjs/operators'], factory) :
    (factory((global['ngx-timeago'] = {}),global.ng.core,global.rxjs,global.rxjs.operators));
}(this, (function (exports,core,rxjs,operators) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b)
            if (b.hasOwnProperty(p))
                d[p] = b[p]; };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * @param {?} value
     * @return {?}
     */
    function isDefined(value) {
        return typeof value !== 'undefined' && value !== null;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    function coerceBooleanProperty(value) {
        return value != null && "" + value !== 'false';
    }
    /**
     * @param {?} date
     * @return {?}
     */
    function dateParser(date) {
        var /** @type {?} */ parsed = new Date(date);
        if (!Number.isNaN(parsed.valueOf())) {
            return parsed;
        }
        var /** @type {?} */ parts = String(date).match(/\d+/g);
        if (parts === null || parts.length <= 2) {
            return parsed;
        }
        else {
            var _a = __read(parts.map(function (x) { return parseInt(x, 10); })), firstP = _a[0], secondP = _a[1], restPs = _a.slice(2);
            return new Date(Date.UTC.apply(Date, __spread([firstP, secondP - 1], restPs)));
        }
    }
    var /** @type {?} */ MINUTE = 60;
    var /** @type {?} */ HOUR = MINUTE * 60;
    var /** @type {?} */ DAY = HOUR * 24;
    var /** @type {?} */ WEEK = DAY * 7;
    var /** @type {?} */ MONTH = DAY * 30;
    var /** @type {?} */ YEAR = DAY * 365;

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * @abstract
     */
    var /**
     * @abstract
     */ TimeagoClock = (function () {
        function TimeagoClock() {
        }
        return TimeagoClock;
    }());
    var TimeagoDefaultClock = (function (_super) {
        __extends(TimeagoDefaultClock, _super);
        function TimeagoDefaultClock() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @param {?} then
         * @return {?}
         */
        TimeagoDefaultClock.prototype.tick = /**
         * @param {?} then
         * @return {?}
         */
            function (then) {
                return rxjs.of(0)
                    .pipe(operators.expand(function () {
                    var /** @type {?} */ now = Date.now();
                    var /** @type {?} */ seconds = Math.round(Math.abs(now - then) / 1000);
                    var /** @type {?} */ period = seconds < MINUTE
                        ? 1000
                        : seconds < HOUR
                            ? 1000 * MINUTE
                            : seconds < DAY
                                ? 1000 * HOUR
                                : 0;
                    return period ? rxjs.timer(period) : rxjs.empty();
                }), operators.skip(1));
            };
        TimeagoDefaultClock.decorators = [
            { type: core.Injectable },
        ];
        return TimeagoDefaultClock;
    }(TimeagoClock));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * To modify the text displayed, create a new instance of TimeagoIntl and
     * include it in a custom provider
     */
    var TimeagoIntl = (function () {
        function TimeagoIntl() {
            /**
             * Stream that emits whenever the l10n strings are changed
             * Use this to notify directives if the l10n strings have changed after initialization.
             */
            this.changes = new rxjs.Subject();
        }
        TimeagoIntl.decorators = [
            { type: core.Injectable },
        ];
        return TimeagoIntl;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ defaultFormattter = function (then) {
        var /** @type {?} */ now = Date.now();
        var /** @type {?} */ seconds = Math.round(Math.abs(now - then) / 1000);
        var /** @type {?} */ suffix = then < now ? 'ago' : 'from now';
        var _a = __read(seconds < MINUTE
            ? [Math.round(seconds), 'second']
            : seconds < HOUR
                ? [Math.round(seconds / MINUTE), 'minute']
                : seconds < DAY
                    ? [Math.round(seconds / HOUR), 'hour']
                    : seconds < WEEK
                        ? [Math.round(seconds / DAY), 'day']
                        : seconds < MONTH
                            ? [Math.round(seconds / WEEK), 'week']
                            : seconds < YEAR
                                ? [Math.round(seconds / MONTH), 'month']
                                : [Math.round(seconds / YEAR), 'year'], 2), value = _a[0], unit = _a[1];
        return { value: value, unit: unit, suffix: suffix };
    };
    /**
     * @abstract
     */
    var /**
     * @abstract
     */ TimeagoFormatter = (function () {
        function TimeagoFormatter() {
        }
        return TimeagoFormatter;
    }());
    var TimeagoDefaultFormatter = (function (_super) {
        __extends(TimeagoDefaultFormatter, _super);
        function TimeagoDefaultFormatter() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @param {?} then
         * @return {?}
         */
        TimeagoDefaultFormatter.prototype.format = /**
         * @param {?} then
         * @return {?}
         */
            function (then) {
                var _a = defaultFormattter(then), suffix = _a.suffix, value = _a.value, unit = _a.unit;
                return this.parse(value, unit, suffix);
            };
        /**
         * @param {?} value
         * @param {?} unit
         * @param {?} suffix
         * @return {?}
         */
        TimeagoDefaultFormatter.prototype.parse = /**
         * @param {?} value
         * @param {?} unit
         * @param {?} suffix
         * @return {?}
         */
            function (value, unit, suffix) {
                if (value !== 1) {
                    unit += 's';
                }
                return value + ' ' + unit + ' ' + suffix;
            };
        TimeagoDefaultFormatter.decorators = [
            { type: core.Injectable },
        ];
        return TimeagoDefaultFormatter;
    }(TimeagoFormatter));
    var TimeagoCustomFormatter = (function (_super) {
        __extends(TimeagoCustomFormatter, _super);
        function TimeagoCustomFormatter(intl) {
            var _this = _super.call(this) || this;
            _this.intl = intl;
            return _this;
        }
        /**
         * @param {?} then
         * @return {?}
         */
        TimeagoCustomFormatter.prototype.format = /**
         * @param {?} then
         * @return {?}
         */
            function (then) {
                var _a = defaultFormattter(then), suffix = _a.suffix, value = _a.value, unit = _a.unit;
                return this.parse(value, unit, suffix, Date.now(), then);
            };
        /**
         * @param {?} value
         * @param {?} unit
         * @param {?} suffix
         * @param {?} now
         * @param {?} then
         * @return {?}
         */
        TimeagoCustomFormatter.prototype.parse = /**
         * @param {?} value
         * @param {?} unit
         * @param {?} suffix
         * @param {?} now
         * @param {?} then
         * @return {?}
         */
            function (value, unit, suffix, now, then) {
                /** convert weeks to days if strings don't handle weeks */
                if (unit === 'week' && !this.intl.strings.week && !this.intl.strings.weeks) {
                    var /** @type {?} */ days = Math.round(Math.abs(now - then) / (1000 * 60 * 60 * 24));
                    value = days;
                    unit = 'day';
                }
                /**
                 * create a normalize function for given value
                 */
                var /** @type {?} */ normalize = this.normalizeFn(value, now - then, this.intl.strings.numbers);
                /**
                 * The eventual return value stored in an array so that the wordSeparator can be used
                 */
                var /** @type {?} */ dateString = [];
                /** handle prefixes */
                if (suffix === 'ago' && this.intl.strings.prefixAgo) {
                    dateString.push(normalize(this.intl.strings.prefixAgo));
                }
                if (suffix === 'from now' && this.intl.strings.prefixFromNow) {
                    dateString.push(normalize(this.intl.strings.prefixFromNow));
                }
                /**
                 * Handle Main number and unit
                 */
                var /** @type {?} */ isPlural = value > 1;
                if (isPlural) {
                    var /** @type {?} */ stringFn = this.intl.strings[unit + 's'] || this.intl.strings[unit] || '%d ' + unit;
                    dateString.push(normalize(stringFn));
                }
                else {
                    var /** @type {?} */ stringFn = this.intl.strings[unit] || this.intl.strings[unit + 's'] || '%d ' + unit;
                    dateString.push(normalize(stringFn));
                }
                /** Handle Suffixes */
                if (suffix === 'ago' && this.intl.strings.suffixAgo) {
                    dateString.push(normalize(this.intl.strings.suffixAgo));
                }
                if (suffix === 'from now' && this.intl.strings.suffixFromNow) {
                    dateString.push(normalize(this.intl.strings.suffixFromNow));
                }
                /**
                 * join the array into a string and return it
                 */
                var /** @type {?} */ wordSeparator = typeof this.intl.strings.wordSeparator === 'string' ? this.intl.strings.wordSeparator : ' ';
                return dateString.join(wordSeparator);
            };
        /**
         * If the numbers array is present, format numbers with it,
         * otherwise just cast the number to a string and return it
         * @param {?} numbers
         * @param {?} value
         * @return {?}
         */
        TimeagoCustomFormatter.prototype.normalizeNumber = /**
         * If the numbers array is present, format numbers with it,
         * otherwise just cast the number to a string and return it
         * @param {?} numbers
         * @param {?} value
         * @return {?}
         */
            function (numbers, value) {
                return numbers && numbers.length === 10
                    ? String(value).split('')
                        .map(function (digit) { return digit.match(/^[0-9]$/) ? numbers[parseInt(digit, 10)] : digit; })
                        .join('')
                    : String(value);
            };
        /**
         * Take a string or a function that takes number of days and returns a string
         * and provide a uniform API to create string parts
         * @param {?} value
         * @param {?} millisDelta
         * @param {?=} numbers
         * @return {?}
         */
        TimeagoCustomFormatter.prototype.normalizeFn = /**
         * Take a string or a function that takes number of days and returns a string
         * and provide a uniform API to create string parts
         * @param {?} value
         * @param {?} millisDelta
         * @param {?=} numbers
         * @return {?}
         */
            function (value, millisDelta, numbers) {
                var _this = this;
                return function (stringOrFn) {
                    return typeof stringOrFn === 'function'
                        ? stringOrFn(value, millisDelta).replace(/%d/g, _this.normalizeNumber(numbers, value))
                        : stringOrFn.replace(/%d/g, _this.normalizeNumber(numbers, value));
                };
            };
        TimeagoCustomFormatter.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        TimeagoCustomFormatter.ctorParameters = function () {
            return [
                { type: TimeagoIntl }
            ];
        };
        return TimeagoCustomFormatter;
    }(TimeagoFormatter));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TimeagoDirective = (function () {
        function TimeagoDirective(intl, cd, formatter, element, clock) {
            var _this = this;
            this.cd = cd;
            this.clock = clock;
            /**
             * Emits on:
             * - Input change
             * - Intl change
             * - Clock tick
             */
            this.stateChanges = new rxjs.Subject();
            this._live = true;
            if (intl) {
                this.intlSubscription = intl.changes.subscribe(function () { return _this.stateChanges.next(); });
            }
            this.stateChanges.subscribe(function () {
                _this.setContent(element.nativeElement, formatter.format(_this.date));
                _this.cd.markForCheck();
            });
        }
        Object.defineProperty(TimeagoDirective.prototype, "date", {
            /** The Date to display. An actual Date object or something that can be fed to new Date. */
            get: /**
             * The Date to display. An actual Date object or something that can be fed to new Date.
             * @return {?}
             */ function () {
                return this._date;
            },
            set: /**
             * @param {?} date
             * @return {?}
             */ function (date) {
                var _this = this;
                this._date = dateParser(date).valueOf();
                if (this._date) {
                    if (this.clockSubscription) {
                        this.clockSubscription.unsubscribe();
                        this.clockSubscription = undefined;
                    }
                    this.clockSubscription = this.clock.tick(this.date)
                        .pipe(operators.filter(function () { return _this.live; }, this))
                        .subscribe(function () { return _this.stateChanges.next(); });
                }
                else {
                    throw new SyntaxError("Wrong parameter in TimeagoDirective. Expected a valid date, received: " + date);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TimeagoDirective.prototype, "live", {
            /** If the directive should update itself over time */
            get: /**
             * If the directive should update itself over time
             * @return {?}
             */ function () {
                return this._live;
            },
            set: /**
             * @param {?} live
             * @return {?}
             */ function (live) {
                this._live = coerceBooleanProperty(live);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        TimeagoDirective.prototype.ngOnChanges = /**
         * @return {?}
         */
            function () {
                this.stateChanges.next();
            };
        /**
         * @param {?} node
         * @param {?} content
         * @return {?}
         */
        TimeagoDirective.prototype.setContent = /**
         * @param {?} node
         * @param {?} content
         * @return {?}
         */
            function (node, content) {
                if (isDefined(node.textContent)) {
                    node.textContent = content;
                }
                else {
                    node.data = content;
                }
            };
        /**
         * @return {?}
         */
        TimeagoDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                if (this.intlSubscription) {
                    this.intlSubscription.unsubscribe();
                    this.intlSubscription = undefined;
                }
                if (this.clockSubscription) {
                    this.clockSubscription.unsubscribe();
                    this.clockSubscription = undefined;
                }
                this.stateChanges.complete();
            };
        TimeagoDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[timeago]',
                        exportAs: 'timeago',
                    },] },
        ];
        /** @nocollapse */
        TimeagoDirective.ctorParameters = function () {
            return [
                { type: TimeagoIntl, decorators: [{ type: core.Optional }] },
                { type: core.ChangeDetectorRef },
                { type: TimeagoFormatter },
                { type: core.ElementRef },
                { type: TimeagoClock }
            ];
        };
        TimeagoDirective.propDecorators = {
            date: [{ type: core.Input }],
            live: [{ type: core.Input }]
        };
        return TimeagoDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TimeagoPipe = (function () {
        function TimeagoPipe(intl, cd, formatter, clock) {
            var _this = this;
            this.clock = clock;
            this.live = true;
            /**
             * Emits on:
             * - Input change
             * - Intl change
             * - Clock tick
             */
            this.stateChanges = new rxjs.Subject();
            if (intl) {
                this.intlSubscription = intl.changes.subscribe(function () { return _this.stateChanges.next(); });
            }
            this.stateChanges.subscribe(function () {
                _this.value = formatter.format(_this.date);
                cd.markForCheck();
            });
        }
        /**
         * @param {?} date
         * @param {...?} args
         * @return {?}
         */
        TimeagoPipe.prototype.transform = /**
         * @param {?} date
         * @param {...?} args
         * @return {?}
         */
            function (date) {
                var _this = this;
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                var /** @type {?} */ _date = dateParser(date).valueOf();
                var /** @type {?} */ _live;
                _live = isDefined(args[0])
                    ? coerceBooleanProperty(args[0])
                    : this.live;
                if (this.date === _date && this.live === _live) {
                    return this.value;
                }
                this.date = _date;
                this.live = _live;
                if (this.date) {
                    if (this.clockSubscription) {
                        this.clockSubscription.unsubscribe();
                        this.clockSubscription = undefined;
                    }
                    this.clockSubscription = this.clock.tick(this.date)
                        .pipe(operators.filter(function () { return _this.live; }, this))
                        .subscribe(function () { return _this.stateChanges.next(); });
                    this.stateChanges.next();
                }
                else {
                    throw new SyntaxError("Wrong parameter in TimeagoPipe. Expected a valid date, received: " + date);
                }
                return this.value;
            };
        /**
         * @return {?}
         */
        TimeagoPipe.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                if (this.intlSubscription) {
                    this.intlSubscription.unsubscribe();
                    this.intlSubscription = undefined;
                }
                if (this.clockSubscription) {
                    this.clockSubscription.unsubscribe();
                    this.clockSubscription = undefined;
                }
                this.stateChanges.complete();
            };
        TimeagoPipe.decorators = [
            { type: core.Injectable },
            { type: core.Pipe, args: [{
                        name: 'timeago',
                        pure: false,
                    },] },
        ];
        /** @nocollapse */
        TimeagoPipe.ctorParameters = function () {
            return [
                { type: TimeagoIntl, decorators: [{ type: core.Optional }] },
                { type: core.ChangeDetectorRef },
                { type: TimeagoFormatter },
                { type: TimeagoClock }
            ];
        };
        return TimeagoPipe;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TimeagoModule = (function () {
        function TimeagoModule() {
        }
        /**
         * Use this method in your root module to provide the TimeagoModule
         */
        /**
         * Use this method in your root module to provide the TimeagoModule
         * @param {?=} config
         * @return {?}
         */
        TimeagoModule.forRoot = /**
         * Use this method in your root module to provide the TimeagoModule
         * @param {?=} config
         * @return {?}
         */
            function (config) {
                if (config === void 0) {
                    config = {};
                }
                return {
                    ngModule: TimeagoModule,
                    providers: [
                        config.clock || { provide: TimeagoClock, useClass: TimeagoDefaultClock },
                        config.intl || [],
                        config.formatter || { provide: TimeagoFormatter, useClass: TimeagoDefaultFormatter },
                    ],
                };
            };
        /**
         * Use this method in your other (non root) modules to import the directive/pipe
         */
        /**
         * Use this method in your other (non root) modules to import the directive/pipe
         * @param {?=} config
         * @return {?}
         */
        TimeagoModule.forChild = /**
         * Use this method in your other (non root) modules to import the directive/pipe
         * @param {?=} config
         * @return {?}
         */
            function (config) {
                if (config === void 0) {
                    config = {};
                }
                return {
                    ngModule: TimeagoModule,
                    providers: [
                        config.clock || { provide: TimeagoClock, useClass: TimeagoDefaultClock },
                        config.intl || [],
                        config.formatter || { provide: TimeagoFormatter, useClass: TimeagoDefaultFormatter },
                    ],
                };
            };
        TimeagoModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            TimeagoDirective,
                            TimeagoPipe,
                        ],
                        exports: [
                            TimeagoDirective,
                            TimeagoPipe,
                        ],
                    },] },
        ];
        return TimeagoModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    exports.TimeagoDirective = TimeagoDirective;
    exports.TimeagoPipe = TimeagoPipe;
    exports.TimeagoIntl = TimeagoIntl;
    exports.TimeagoClock = TimeagoClock;
    exports.TimeagoDefaultClock = TimeagoDefaultClock;
    exports.TimeagoFormatter = TimeagoFormatter;
    exports.TimeagoDefaultFormatter = TimeagoDefaultFormatter;
    exports.TimeagoCustomFormatter = TimeagoCustomFormatter;
    exports.TimeagoModule = TimeagoModule;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LXRpbWVhZ28udW1kLmpzLm1hcCIsInNvdXJjZXMiOltudWxsLCJuZzovL25neC10aW1lYWdvL3V0aWwudHMiLCJuZzovL25neC10aW1lYWdvL3RpbWVhZ28uY2xvY2sudHMiLCJuZzovL25neC10aW1lYWdvL3RpbWVhZ28uaW50bC50cyIsIm5nOi8vbmd4LXRpbWVhZ28vdGltZWFnby5mb3JtYXR0ZXIudHMiLCJuZzovL25neC10aW1lYWdvL3RpbWVhZ28uZGlyZWN0aXZlLnRzIiwibmc6Ly9uZ3gtdGltZWFnby90aW1lYWdvLnBpcGUudHMiLCJuZzovL25neC10aW1lYWdvL3RpbWVhZ28ubW9kdWxlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcblNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIGlmIChlLmluZGV4T2YocFtpXSkgPCAwKVxyXG4gICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcGFyYW0ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0geVtvcFswXSAmIDIgPyBcInJldHVyblwiIDogb3BbMF0gPyBcInRocm93XCIgOiBcIm5leHRcIl0pICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gWzAsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXhwb3J0U3RhcihtLCBleHBvcnRzKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3JlYWQobywgbikge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWQoKSB7XHJcbiAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0KHYpIHtcclxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7ICB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcclxuICAgIHZhciBpLCBwO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpZiAob1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXTtcclxuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpIHtcclxuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XHJcbiAgICByZXR1cm4gY29va2VkO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0U3Rhcihtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xyXG4gICAgcmVzdWx0LmRlZmF1bHQgPSBtb2Q7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnREZWZhdWx0KG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBkZWZhdWx0OiBtb2QgfTtcclxufVxyXG4iLCJleHBvcnQgZnVuY3Rpb24gaXNEZWZpbmVkKHZhbHVlOiBhbnkpOiBib29sZWFuIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgIT09IG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWU6IGFueSk6IGJvb2xlYW4ge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBgJHt2YWx1ZX1gICE9PSAnZmFsc2UnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGF0ZVBhcnNlcihkYXRlOiBhbnkpOiBEYXRlIHtcbiAgY29uc3QgcGFyc2VkID0gbmV3IERhdGUoZGF0ZSk7XG4gIGlmICghTnVtYmVyLmlzTmFOKHBhcnNlZC52YWx1ZU9mKCkpKSB7XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuXG4gIGNvbnN0IHBhcnRzOiBzdHJpbmdbXSA9IFN0cmluZyhkYXRlKS5tYXRjaCgvXFxkKy9nKTtcbiAgaWYgKHBhcnRzID09PSBudWxsIHx8IHBhcnRzLmxlbmd0aCA8PSAyKSB7XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBbZmlyc3RQLCBzZWNvbmRQLCAuLi5yZXN0UHNdID0gcGFydHMubWFwKHggPT4gcGFyc2VJbnQoeCwgMTApKTtcbiAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoZmlyc3RQLCBzZWNvbmRQIC0gMSwgLi4ucmVzdFBzKSk7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IE1JTlVURSA9IDYwO1xuZXhwb3J0IGNvbnN0IEhPVVIgPSBNSU5VVEUgKiA2MDtcbmV4cG9ydCBjb25zdCBEQVkgPSBIT1VSICogMjQ7XG5leHBvcnQgY29uc3QgV0VFSyA9IERBWSAqIDc7XG5leHBvcnQgY29uc3QgTU9OVEggPSBEQVkgKiAzMDtcbmV4cG9ydCBjb25zdCBZRUFSID0gREFZICogMzY1O1xuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgb2YsIGVtcHR5LCB0aW1lciB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgZXhwYW5kLCBza2lwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgTUlOVVRFLCBIT1VSLCBEQVkgfSBmcm9tICcuL3V0aWwnO1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgVGltZWFnb0Nsb2NrIHtcbiAgYWJzdHJhY3QgdGljayh0aGVuOiBudW1iZXIpOiBPYnNlcnZhYmxlPGFueT47XG59XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBUaW1lYWdvRGVmYXVsdENsb2NrIGV4dGVuZHMgVGltZWFnb0Nsb2NrIHtcbiAgdGljayh0aGVuOiBudW1iZXIpOiBPYnNlcnZhYmxlPGFueT4ge1xuICAgIHJldHVybiBvZigwKVxuICAgICAgLnBpcGUoXG4gICAgICAgIGV4cGFuZCgoKSA9PiB7XG4gICAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICBjb25zdCBzZWNvbmRzID0gTWF0aC5yb3VuZChNYXRoLmFicyhub3cgLSB0aGVuKSAvIDEwMDApO1xuXG4gICAgICAgICAgY29uc3QgcGVyaW9kID1cbiAgICAgICAgICAgIHNlY29uZHMgPCBNSU5VVEVcbiAgICAgICAgICAgICAgPyAxMDAwXG4gICAgICAgICAgICAgIDogc2Vjb25kcyA8IEhPVVJcbiAgICAgICAgICAgICAgICA/IDEwMDAgKiBNSU5VVEVcbiAgICAgICAgICAgICAgICA6IHNlY29uZHMgPCBEQVlcbiAgICAgICAgICAgICAgICAgID8gMTAwMCAqIEhPVVJcbiAgICAgICAgICAgICAgICAgIDogMDtcblxuICAgICAgICAgIHJldHVybiBwZXJpb2QgPyB0aW1lcihwZXJpb2QpIDogZW1wdHkoKTtcbiAgICAgICAgfSksXG4gICAgICAgIHNraXAoMSlcbiAgICAgICk7XG4gIH1cbn1cbiIsImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFN0cmluZ09yRm4sIE51bWJlckFycmF5IH0gZnJvbSAnLi90aW1lYWdvLmZvcm1hdHRlcic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUwxMG5zU3RyaW5ncyB7XG4gIHByZWZpeEFnbz86IFN0cmluZ09yRm47XG4gIHByZWZpeEZyb21Ob3c/OiBTdHJpbmdPckZuO1xuICBzdWZmaXhBZ28/OiBTdHJpbmdPckZuO1xuICBzdWZmaXhGcm9tTm93PzogU3RyaW5nT3JGbjtcbiAgc2Vjb25kPzogU3RyaW5nT3JGbjtcbiAgc2Vjb25kcz86IFN0cmluZ09yRm47XG4gIG1pbnV0ZT86IFN0cmluZ09yRm47XG4gIG1pbnV0ZXM/OiBTdHJpbmdPckZuO1xuICBob3VyPzogU3RyaW5nT3JGbjtcbiAgaG91cnM/OiBTdHJpbmdPckZuO1xuICBkYXk/OiBTdHJpbmdPckZuO1xuICBkYXlzPzogU3RyaW5nT3JGbjtcbiAgd2Vlaz86IFN0cmluZ09yRm47XG4gIHdlZWtzPzogU3RyaW5nT3JGbjtcbiAgbW9udGg/OiBTdHJpbmdPckZuO1xuICBtb250aHM/OiBTdHJpbmdPckZuO1xuICB5ZWFyPzogU3RyaW5nT3JGbjtcbiAgeWVhcnM/OiBTdHJpbmdPckZuO1xuICB3b3JkU2VwYXJhdG9yPzogc3RyaW5nO1xuICBudW1iZXJzPzogTnVtYmVyQXJyYXk7XG59O1xuXG4vKipcbiAqIFRvIG1vZGlmeSB0aGUgdGV4dCBkaXNwbGF5ZWQsIGNyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBUaW1lYWdvSW50bCBhbmRcbiAqIGluY2x1ZGUgaXQgaW4gYSBjdXN0b20gcHJvdmlkZXJcbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFRpbWVhZ29JbnRsIHtcblxuICBzdHJpbmdzOiBJTDEwbnNTdHJpbmdzO1xuXG4gIC8qKlxuICAgKiBTdHJlYW0gdGhhdCBlbWl0cyB3aGVuZXZlciB0aGUgbDEwbiBzdHJpbmdzIGFyZSBjaGFuZ2VkXG4gICAqIFVzZSB0aGlzIHRvIG5vdGlmeSBkaXJlY3RpdmVzIGlmIHRoZSBsMTBuIHN0cmluZ3MgaGF2ZSBjaGFuZ2VkIGFmdGVyIGluaXRpYWxpemF0aW9uLlxuICAgKi9cbiAgcmVhZG9ubHkgY2hhbmdlczogU3ViamVjdDx2b2lkPiA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG59XG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBUaW1lYWdvSW50bCB9IGZyb20gJy4vdGltZWFnby5pbnRsJztcbmltcG9ydCB7IE1JTlVURSwgSE9VUiwgREFZLCBXRUVLLCBNT05USCwgWUVBUiB9IGZyb20gJy4vdXRpbCc7XG5cbmV4cG9ydCB0eXBlIFVuaXQgPSAnc2Vjb25kJyB8ICdtaW51dGUnIHwgJ2hvdXInIHwgJ2RheScgfCAnd2VlaycgfCAnbW9udGgnIHwgJ3llYXInO1xuXG5leHBvcnQgdHlwZSBTdWZmaXggPSAnYWdvJyB8ICdmcm9tIG5vdyc7XG5cbmV4cG9ydCB0eXBlIFN0cmluZ09yRm4gPSAoKHZhbHVlOiBudW1iZXIsIG1pbGxpc0RlbHRhOiAgbnVtYmVyKSA9PiBzdHJpbmcpIHwgc3RyaW5nO1xuXG5leHBvcnQgdHlwZSBOdW1iZXJBcnJheSA9IFsgc3RyaW5nLCBzdHJpbmcsIHN0cmluZywgc3RyaW5nLCBzdHJpbmcsIHN0cmluZywgc3RyaW5nLCBzdHJpbmcsIHN0cmluZywgc3RyaW5nIF07XG5cbmNvbnN0IGRlZmF1bHRGb3JtYXR0dGVyID0gZnVuY3Rpb24odGhlbjogbnVtYmVyKToge3ZhbHVlOiBudW1iZXIsIHVuaXQ6IFVuaXQsIHN1ZmZpeDogU3VmZml4fSB7XG4gIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gIGNvbnN0IHNlY29uZHMgPSBNYXRoLnJvdW5kKE1hdGguYWJzKG5vdyAtIHRoZW4pIC8gMTAwMCk7XG4gIGNvbnN0IHN1ZmZpeDogU3VmZml4ID0gdGhlbiA8IG5vdyA/ICdhZ28nIDogJ2Zyb20gbm93JztcblxuICBjb25zdCBbdmFsdWUsIHVuaXRdOiBbbnVtYmVyLCBVbml0XSA9XG4gICAgc2Vjb25kcyA8IE1JTlVURVxuICAgICAgPyBbTWF0aC5yb3VuZChzZWNvbmRzKSwgJ3NlY29uZCddXG4gICAgICA6IHNlY29uZHMgPCBIT1VSXG4gICAgICAgID8gW01hdGgucm91bmQoc2Vjb25kcyAvIE1JTlVURSksICdtaW51dGUnXVxuICAgICAgICA6IHNlY29uZHMgPCBEQVlcbiAgICAgICAgICA/IFtNYXRoLnJvdW5kKHNlY29uZHMgLyBIT1VSKSwgJ2hvdXInXVxuICAgICAgICAgIDogc2Vjb25kcyA8IFdFRUtcbiAgICAgICAgICAgID8gW01hdGgucm91bmQoc2Vjb25kcyAvIERBWSksICdkYXknXVxuICAgICAgICAgICAgOiBzZWNvbmRzIDwgTU9OVEhcbiAgICAgICAgICAgICAgPyBbTWF0aC5yb3VuZChzZWNvbmRzIC8gV0VFSyksICd3ZWVrJ11cbiAgICAgICAgICAgICAgOiBzZWNvbmRzIDwgWUVBUlxuICAgICAgICAgICAgICAgID8gW01hdGgucm91bmQoc2Vjb25kcyAvIE1PTlRIKSwgJ21vbnRoJ11cbiAgICAgICAgICAgICAgICA6IFtNYXRoLnJvdW5kKHNlY29uZHMgLyBZRUFSKSwgJ3llYXInXTtcblxuICByZXR1cm4ge3ZhbHVlLCB1bml0LCBzdWZmaXh9O1xufVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgVGltZWFnb0Zvcm1hdHRlciB7XG4gIGFic3RyYWN0IGZvcm1hdCh0aGVuOiBudW1iZXIpOiBzdHJpbmdcbn1cblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFRpbWVhZ29EZWZhdWx0Rm9ybWF0dGVyIGV4dGVuZHMgVGltZWFnb0Zvcm1hdHRlciB7XG4gIGZvcm1hdCh0aGVuOiBudW1iZXIpOiBzdHJpbmcge1xuICAgIGNvbnN0IHtzdWZmaXgsIHZhbHVlLCB1bml0fSA9IGRlZmF1bHRGb3JtYXR0dGVyKHRoZW4pO1xuICAgIHJldHVybiB0aGlzLnBhcnNlKHZhbHVlLCB1bml0LCBzdWZmaXgpO1xuICB9XG5cbiAgcHJpdmF0ZSBwYXJzZSh2YWx1ZTogbnVtYmVyLCB1bml0OiBVbml0LCBzdWZmaXg6IFN1ZmZpeCk6IHN0cmluZyB7XG4gICAgaWYgKHZhbHVlICE9PSAxKSB7XG4gICAgICB1bml0ICs9ICdzJztcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlICsgJyAnICsgdW5pdCArICcgJyArIHN1ZmZpeDtcbiAgfVxufVxuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgVGltZWFnb0N1c3RvbUZvcm1hdHRlciBleHRlbmRzIFRpbWVhZ29Gb3JtYXR0ZXIge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGludGw6IFRpbWVhZ29JbnRsKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxuXG4gIGZvcm1hdCh0aGVuOiBudW1iZXIpOiBzdHJpbmcge1xuICAgIGNvbnN0IHtzdWZmaXgsIHZhbHVlLCB1bml0fSA9IGRlZmF1bHRGb3JtYXR0dGVyKHRoZW4pO1xuICAgIHJldHVybiB0aGlzLnBhcnNlKHZhbHVlLCB1bml0LCBzdWZmaXgsIERhdGUubm93KCksIHRoZW4pO1xuICB9XG5cbiAgcHJpdmF0ZSBwYXJzZSh2YWx1ZTogbnVtYmVyLCB1bml0OiBVbml0LCBzdWZmaXg6IFN1ZmZpeCwgbm93OiBudW1iZXIsIHRoZW46IG51bWJlcikge1xuICAgIC8qKiBjb252ZXJ0IHdlZWtzIHRvIGRheXMgaWYgc3RyaW5ncyBkb24ndCBoYW5kbGUgd2Vla3MgKi9cbiAgICBpZiAodW5pdCA9PT0gJ3dlZWsnICYmICF0aGlzLmludGwuc3RyaW5ncy53ZWVrICYmICF0aGlzLmludGwuc3RyaW5ncy53ZWVrcykge1xuICAgICAgY29uc3QgZGF5cyA9IE1hdGgucm91bmQoTWF0aC5hYnMobm93IC0gdGhlbikgLyAoMTAwMCAqIDYwICogNjAgKiAyNCkpO1xuICAgICAgdmFsdWUgPSBkYXlzO1xuICAgICAgdW5pdCA9ICdkYXknO1xuICAgIH1cblxuICAgIC8qKiBjcmVhdGUgYSBub3JtYWxpemUgZnVuY3Rpb24gZm9yIGdpdmVuIHZhbHVlICovXG4gICAgY29uc3Qgbm9ybWFsaXplID0gdGhpcy5ub3JtYWxpemVGbih2YWx1ZSwgbm93IC0gdGhlbiwgdGhpcy5pbnRsLnN0cmluZ3MubnVtYmVycyk7XG5cbiAgICAvKiogVGhlIGV2ZW50dWFsIHJldHVybiB2YWx1ZSBzdG9yZWQgaW4gYW4gYXJyYXkgc28gdGhhdCB0aGUgd29yZFNlcGFyYXRvciBjYW4gYmUgdXNlZCAqL1xuICAgIGNvbnN0IGRhdGVTdHJpbmc6IHN0cmluZ1tdID0gW107XG5cbiAgICAvKiogaGFuZGxlIHByZWZpeGVzICovXG4gICAgaWYgKHN1ZmZpeCA9PT0gJ2FnbycgJiYgdGhpcy5pbnRsLnN0cmluZ3MucHJlZml4QWdvKSB7XG4gICAgICBkYXRlU3RyaW5nLnB1c2gobm9ybWFsaXplKHRoaXMuaW50bC5zdHJpbmdzLnByZWZpeEFnbykpO1xuICAgIH1cbiAgICBpZiAoc3VmZml4ID09PSAnZnJvbSBub3cnICYmIHRoaXMuaW50bC5zdHJpbmdzLnByZWZpeEZyb21Ob3cpIHtcbiAgICAgIGRhdGVTdHJpbmcucHVzaChub3JtYWxpemUodGhpcy5pbnRsLnN0cmluZ3MucHJlZml4RnJvbU5vdykpO1xuICAgIH1cblxuICAgIC8qKiBIYW5kbGUgTWFpbiBudW1iZXIgYW5kIHVuaXQgKi9cbiAgICBjb25zdCBpc1BsdXJhbCA9IHZhbHVlID4gMTtcbiAgICBpZiAoaXNQbHVyYWwpIHtcbiAgICAgIGNvbnN0IHN0cmluZ0ZuOiBTdHJpbmdPckZuID0gdGhpcy5pbnRsLnN0cmluZ3NbdW5pdCArICdzJ10gfHwgdGhpcy5pbnRsLnN0cmluZ3NbdW5pdF0gfHwgJyVkICcgKyB1bml0O1xuICAgICAgZGF0ZVN0cmluZy5wdXNoKG5vcm1hbGl6ZShzdHJpbmdGbikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzdHJpbmdGbjogU3RyaW5nT3JGbiA9IHRoaXMuaW50bC5zdHJpbmdzW3VuaXRdIHx8IHRoaXMuaW50bC5zdHJpbmdzW3VuaXQgKyAncyddIHx8ICclZCAnICsgdW5pdDtcbiAgICAgIGRhdGVTdHJpbmcucHVzaChub3JtYWxpemUoc3RyaW5nRm4pKTtcbiAgICB9XG5cbiAgICAvKiogSGFuZGxlIFN1ZmZpeGVzICovXG4gICAgaWYgKHN1ZmZpeCA9PT0gJ2FnbycgJiYgdGhpcy5pbnRsLnN0cmluZ3Muc3VmZml4QWdvKSB7XG4gICAgICBkYXRlU3RyaW5nLnB1c2gobm9ybWFsaXplKHRoaXMuaW50bC5zdHJpbmdzLnN1ZmZpeEFnbykpO1xuICAgIH1cbiAgICBpZiAoc3VmZml4ID09PSAnZnJvbSBub3cnICYmIHRoaXMuaW50bC5zdHJpbmdzLnN1ZmZpeEZyb21Ob3cpIHtcbiAgICAgIGRhdGVTdHJpbmcucHVzaChub3JtYWxpemUodGhpcy5pbnRsLnN0cmluZ3Muc3VmZml4RnJvbU5vdykpO1xuICAgIH1cblxuICAgIC8qKiBqb2luIHRoZSBhcnJheSBpbnRvIGEgc3RyaW5nIGFuZCByZXR1cm4gaXQgKi9cbiAgICBjb25zdCB3b3JkU2VwYXJhdG9yID0gdHlwZW9mIHRoaXMuaW50bC5zdHJpbmdzLndvcmRTZXBhcmF0b3IgPT09ICdzdHJpbmcnID8gdGhpcy5pbnRsLnN0cmluZ3Mud29yZFNlcGFyYXRvciA6ICcgJztcbiAgICByZXR1cm4gZGF0ZVN0cmluZy5qb2luKHdvcmRTZXBhcmF0b3IpO1xuICB9XG5cbiAgLyoqXG4gICAqIElmIHRoZSBudW1iZXJzIGFycmF5IGlzIHByZXNlbnQsIGZvcm1hdCBudW1iZXJzIHdpdGggaXQsXG4gICAqIG90aGVyd2lzZSBqdXN0IGNhc3QgdGhlIG51bWJlciB0byBhIHN0cmluZyBhbmQgcmV0dXJuIGl0XG4gICovXG4gIHByaXZhdGUgbm9ybWFsaXplTnVtYmVyKG51bWJlcnM6IE51bWJlckFycmF5LCB2YWx1ZTogbnVtYmVyKSB7XG4gICAgcmV0dXJuIG51bWJlcnMgJiYgbnVtYmVycy5sZW5ndGggPT09IDEwXG4gICAgICA/IFN0cmluZyh2YWx1ZSkuc3BsaXQoJycpXG4gICAgICAgICAgLm1hcCgoZGlnaXQ6IHN0cmluZykgPT4gZGlnaXQubWF0Y2goL15bMC05XSQvKSA/IG51bWJlcnNbcGFyc2VJbnQoZGlnaXQsIDEwKV0gOiBkaWdpdClcbiAgICAgICAgICAuam9pbignJylcbiAgICAgIDogU3RyaW5nKHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUYWtlIGEgc3RyaW5nIG9yIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBudW1iZXIgb2YgZGF5cyBhbmQgcmV0dXJucyBhIHN0cmluZ1xuICAgKiBhbmQgcHJvdmlkZSBhIHVuaWZvcm0gQVBJIHRvIGNyZWF0ZSBzdHJpbmcgcGFydHNcbiAgKi9cbiAgcHJpdmF0ZSBub3JtYWxpemVGbih2YWx1ZTogbnVtYmVyLCBtaWxsaXNEZWx0YTogbnVtYmVyLCBudW1iZXJzPzogTnVtYmVyQXJyYXkpIHtcbiAgICByZXR1cm4gKHN0cmluZ09yRm46IFN0cmluZ09yRm4pID0+XG4gICAgICB0eXBlb2Ygc3RyaW5nT3JGbiA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBzdHJpbmdPckZuKHZhbHVlLCBtaWxsaXNEZWx0YSkucmVwbGFjZSgvJWQvZywgdGhpcy5ub3JtYWxpemVOdW1iZXIobnVtYmVycywgdmFsdWUpKVxuICAgICAgOiBzdHJpbmdPckZuLnJlcGxhY2UoLyVkL2csIHRoaXMubm9ybWFsaXplTnVtYmVyKG51bWJlcnMsIHZhbHVlKSk7XG4gIH1cbn1cbiIsImltcG9ydCB7IERpcmVjdGl2ZSwgSW5wdXQsIEVsZW1lbnRSZWYsIE9wdGlvbmFsLCBPbkNoYW5nZXMsIE9uRGVzdHJveSwgQ2hhbmdlRGV0ZWN0b3JSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiwgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgZmlsdGVyIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgVGltZWFnb0Nsb2NrIH0gZnJvbSAnLi90aW1lYWdvLmNsb2NrJztcbmltcG9ydCB7IFRpbWVhZ29Gb3JtYXR0ZXIgfSBmcm9tICcuL3RpbWVhZ28uZm9ybWF0dGVyJztcbmltcG9ydCB7IFRpbWVhZ29JbnRsIH0gZnJvbSAnLi90aW1lYWdvLmludGwnO1xuaW1wb3J0IHsgaXNEZWZpbmVkLCBjb2VyY2VCb29sZWFuUHJvcGVydHksIGRhdGVQYXJzZXIgfSBmcm9tICcuL3V0aWwnO1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbdGltZWFnb10nLFxuICBleHBvcnRBczogJ3RpbWVhZ28nLFxufSlcbmV4cG9ydCBjbGFzcyBUaW1lYWdvRGlyZWN0aXZlIGltcGxlbWVudHMgT25DaGFuZ2VzLCBPbkRlc3Ryb3kge1xuICBwcml2YXRlIGludGxTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcbiAgcHJpdmF0ZSBjbG9ja1N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gIC8qKlxuICAgKiBFbWl0cyBvbjpcbiAgICogLSBJbnB1dCBjaGFuZ2VcbiAgICogLSBJbnRsIGNoYW5nZVxuICAgKiAtIENsb2NrIHRpY2tcbiAgKi9cbiAgc3RhdGVDaGFuZ2VzID0gbmV3IFN1YmplY3Q8YW55PigpO1xuXG4gIC8qKiBUaGUgRGF0ZSB0byBkaXNwbGF5LiBBbiBhY3R1YWwgRGF0ZSBvYmplY3Qgb3Igc29tZXRoaW5nIHRoYXQgY2FuIGJlIGZlZCB0byBuZXcgRGF0ZS4gKi9cbiAgQElucHV0KClcbiAgZ2V0IGRhdGUoKTogYW55IHtcbiAgICByZXR1cm4gdGhpcy5fZGF0ZTtcbiAgfVxuICBzZXQgZGF0ZShkYXRlOiBhbnkpIHtcbiAgICB0aGlzLl9kYXRlID0gZGF0ZVBhcnNlcihkYXRlKS52YWx1ZU9mKCk7XG4gICAgaWYgKHRoaXMuX2RhdGUpIHtcbiAgICAgIGlmICh0aGlzLmNsb2NrU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgIHRoaXMuY2xvY2tTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgdGhpcy5jbG9ja1N1YnNjcmlwdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2xvY2tTdWJzY3JpcHRpb24gPSB0aGlzLmNsb2NrLnRpY2sodGhpcy5kYXRlKVxuICAgICAgICAucGlwZShmaWx0ZXIoKCkgPT4gdGhpcy5saXZlLCB0aGlzKSlcbiAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLnN0YXRlQ2hhbmdlcy5uZXh0KCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFdyb25nIHBhcmFtZXRlciBpbiBUaW1lYWdvRGlyZWN0aXZlLiBFeHBlY3RlZCBhIHZhbGlkIGRhdGUsIHJlY2VpdmVkOiAke2RhdGV9YCk7XG4gICAgfVxuICB9XG4gIHByaXZhdGUgX2RhdGU6IG51bWJlcjtcblxuICAvKiogSWYgdGhlIGRpcmVjdGl2ZSBzaG91bGQgdXBkYXRlIGl0c2VsZiBvdmVyIHRpbWUgKi9cbiAgQElucHV0KClcbiAgZ2V0IGxpdmUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2xpdmU7XG4gIH1cbiAgc2V0IGxpdmUobGl2ZTogYm9vbGVhbikge1xuICAgIHRoaXMuX2xpdmUgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkobGl2ZSk7XG4gIH1cbiAgcHJpdmF0ZSBfbGl2ZSA9IHRydWU7XG5cbiAgY29uc3RydWN0b3IoQE9wdGlvbmFsKCkgaW50bDogVGltZWFnb0ludGwsXG4gICAgICAgICAgICAgIHByaXZhdGUgY2Q6IENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICAgICAgICBmb3JtYXR0ZXI6IFRpbWVhZ29Gb3JtYXR0ZXIsXG4gICAgICAgICAgICAgIGVsZW1lbnQ6IEVsZW1lbnRSZWYsXG4gICAgICAgICAgICAgIHByaXZhdGUgY2xvY2s6IFRpbWVhZ29DbG9jaykge1xuICAgIGlmIChpbnRsKSB7XG4gICAgICB0aGlzLmludGxTdWJzY3JpcHRpb24gPSBpbnRsLmNoYW5nZXMuc3Vic2NyaWJlKCgpID0+IHRoaXMuc3RhdGVDaGFuZ2VzLm5leHQoKSk7XG4gICAgfVxuICAgIHRoaXMuc3RhdGVDaGFuZ2VzLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICB0aGlzLnNldENvbnRlbnQoZWxlbWVudC5uYXRpdmVFbGVtZW50LCBmb3JtYXR0ZXIuZm9ybWF0KHRoaXMuZGF0ZSkpO1xuICAgICAgdGhpcy5jZC5tYXJrRm9yQ2hlY2soKTtcbiAgICB9KTtcbiAgfVxuXG4gIG5nT25DaGFuZ2VzKCkge1xuICAgIHRoaXMuc3RhdGVDaGFuZ2VzLm5leHQoKTtcbiAgfVxuXG4gIHNldENvbnRlbnQobm9kZTogYW55LCBjb250ZW50OiBzdHJpbmcpIHtcbiAgICBpZiAoaXNEZWZpbmVkKG5vZGUudGV4dENvbnRlbnQpKSB7XG4gICAgICBub2RlLnRleHRDb250ZW50ID0gY29udGVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5kYXRhID0gY29udGVudDtcbiAgICB9XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5pbnRsU3Vic2NyaXB0aW9uKSB7XG4gICAgICB0aGlzLmludGxTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgIHRoaXMuaW50bFN1YnNjcmlwdGlvbiA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKHRoaXMuY2xvY2tTdWJzY3JpcHRpb24pIHtcbiAgICAgIHRoaXMuY2xvY2tTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgIHRoaXMuY2xvY2tTdWJzY3JpcHRpb24gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHRoaXMuc3RhdGVDaGFuZ2VzLmNvbXBsZXRlKCk7XG4gIH1cbn1cbiIsImltcG9ydCB7IEluamVjdGFibGUsIE9uRGVzdHJveSwgUGlwZSwgUGlwZVRyYW5zZm9ybSwgT3B0aW9uYWwsIENoYW5nZURldGVjdG9yUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24sIFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFRpbWVhZ29DbG9jayB9IGZyb20gJy4vdGltZWFnby5jbG9jayc7XG5pbXBvcnQgeyBUaW1lYWdvRm9ybWF0dGVyIH0gZnJvbSAnLi90aW1lYWdvLmZvcm1hdHRlcic7XG5pbXBvcnQgeyBUaW1lYWdvSW50bCB9IGZyb20gJy4vdGltZWFnby5pbnRsJztcbmltcG9ydCB7IGlzRGVmaW5lZCwgY29lcmNlQm9vbGVhblByb3BlcnR5LCBkYXRlUGFyc2VyIH0gZnJvbSAnLi91dGlsJztcbmltcG9ydCB7IGZpbHRlciB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuQEluamVjdGFibGUoKVxuQFBpcGUoe1xuICBuYW1lOiAndGltZWFnbycsXG4gIHB1cmU6IGZhbHNlLCAvLyByZXF1aXJlZCB0byB1cGRhdGUgdGhlIHZhbHVlIHdoZW4gc3RhdGVDaGFuZ2VzIGVtaXRzXG59KVxuZXhwb3J0IGNsYXNzIFRpbWVhZ29QaXBlIGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSwgT25EZXN0cm95IHtcbiAgcHJpdmF0ZSBpbnRsU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG4gIHByaXZhdGUgY2xvY2tTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICBwcml2YXRlIGRhdGU6IG51bWJlcjtcbiAgcHJpdmF0ZSB2YWx1ZTogc3RyaW5nO1xuICBwcml2YXRlIGxpdmUgPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBFbWl0cyBvbjpcbiAgICogLSBJbnB1dCBjaGFuZ2VcbiAgICogLSBJbnRsIGNoYW5nZVxuICAgKiAtIENsb2NrIHRpY2tcbiAgKi9cbiAgc3RhdGVDaGFuZ2VzID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICBjb25zdHJ1Y3RvcihAT3B0aW9uYWwoKSBpbnRsOiBUaW1lYWdvSW50bCxcbiAgICBjZDogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgZm9ybWF0dGVyOiBUaW1lYWdvRm9ybWF0dGVyLFxuICAgIHByaXZhdGUgY2xvY2s6IFRpbWVhZ29DbG9jaykge1xuICAgIGlmIChpbnRsKSB7XG4gICAgICB0aGlzLmludGxTdWJzY3JpcHRpb24gPSBpbnRsLmNoYW5nZXMuc3Vic2NyaWJlKCgpID0+IHRoaXMuc3RhdGVDaGFuZ2VzLm5leHQoKSk7XG4gICAgfVxuICAgIHRoaXMuc3RhdGVDaGFuZ2VzLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICB0aGlzLnZhbHVlID0gZm9ybWF0dGVyLmZvcm1hdCh0aGlzLmRhdGUpO1xuICAgICAgY2QubWFya0ZvckNoZWNrKCk7XG4gICAgfSk7XG4gIH1cblxuICB0cmFuc2Zvcm0oZGF0ZTogYW55LCAuLi5hcmdzOiBhbnlbXSkge1xuICAgIGNvbnN0IF9kYXRlID0gZGF0ZVBhcnNlcihkYXRlKS52YWx1ZU9mKCk7XG4gICAgbGV0IF9saXZlOiBib29sZWFuO1xuXG4gICAgX2xpdmUgPSBpc0RlZmluZWQoYXJnc1swXSlcbiAgICAgID8gY29lcmNlQm9vbGVhblByb3BlcnR5KGFyZ3NbMF0pXG4gICAgICA6IHRoaXMubGl2ZTtcblxuICAgIGlmICh0aGlzLmRhdGUgPT09IF9kYXRlICYmIHRoaXMubGl2ZSA9PT0gX2xpdmUpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cblxuICAgIHRoaXMuZGF0ZSA9IF9kYXRlO1xuICAgIHRoaXMubGl2ZSA9IF9saXZlO1xuXG4gICAgaWYgKHRoaXMuZGF0ZSkge1xuICAgICAgaWYgKHRoaXMuY2xvY2tTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgdGhpcy5jbG9ja1N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLmNsb2NrU3Vic2NyaXB0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgdGhpcy5jbG9ja1N1YnNjcmlwdGlvbiA9IHRoaXMuY2xvY2sudGljayh0aGlzLmRhdGUpXG4gICAgICAgIC5waXBlKGZpbHRlcigoKSA9PiB0aGlzLmxpdmUsIHRoaXMpKVxuICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMuc3RhdGVDaGFuZ2VzLm5leHQoKSk7XG4gICAgICB0aGlzLnN0YXRlQ2hhbmdlcy5uZXh0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgV3JvbmcgcGFyYW1ldGVyIGluIFRpbWVhZ29QaXBlLiBFeHBlY3RlZCBhIHZhbGlkIGRhdGUsIHJlY2VpdmVkOiAke2RhdGV9YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5pbnRsU3Vic2NyaXB0aW9uKSB7XG4gICAgICB0aGlzLmludGxTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgIHRoaXMuaW50bFN1YnNjcmlwdGlvbiA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKHRoaXMuY2xvY2tTdWJzY3JpcHRpb24pIHtcbiAgICAgIHRoaXMuY2xvY2tTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgIHRoaXMuY2xvY2tTdWJzY3JpcHRpb24gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHRoaXMuc3RhdGVDaGFuZ2VzLmNvbXBsZXRlKCk7XG4gIH1cbn1cbiIsImltcG9ydCB7IE5nTW9kdWxlLCBNb2R1bGVXaXRoUHJvdmlkZXJzLCBQcm92aWRlciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVGltZWFnb0RpcmVjdGl2ZSB9IGZyb20gJy4vdGltZWFnby5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgVGltZWFnb1BpcGUgfSBmcm9tICcuL3RpbWVhZ28ucGlwZSc7XG5pbXBvcnQgeyBUaW1lYWdvQ2xvY2ssIFRpbWVhZ29EZWZhdWx0Q2xvY2sgfSBmcm9tICcuL3RpbWVhZ28uY2xvY2snO1xuaW1wb3J0IHsgVGltZWFnb0Zvcm1hdHRlciwgVGltZWFnb0RlZmF1bHRGb3JtYXR0ZXIgfSBmcm9tICcuL3RpbWVhZ28uZm9ybWF0dGVyJztcblxuZXhwb3J0IGludGVyZmFjZSBUaW1lYWdvTW9kdWxlQ29uZmlnIHtcbiAgY2xvY2s/OiBQcm92aWRlcjtcbiAgaW50bD86IFByb3ZpZGVyO1xuICBmb3JtYXR0ZXI/OiBQcm92aWRlcjtcbn1cblxuQE5nTW9kdWxlKHtcbiAgZGVjbGFyYXRpb25zOiBbXG4gICAgVGltZWFnb0RpcmVjdGl2ZSxcbiAgICBUaW1lYWdvUGlwZSxcbiAgXSxcbiAgZXhwb3J0czogW1xuICAgIFRpbWVhZ29EaXJlY3RpdmUsXG4gICAgVGltZWFnb1BpcGUsXG4gIF0sXG59KVxuZXhwb3J0IGNsYXNzIFRpbWVhZ29Nb2R1bGUge1xuICAvKipcbiAgICogVXNlIHRoaXMgbWV0aG9kIGluIHlvdXIgcm9vdCBtb2R1bGUgdG8gcHJvdmlkZSB0aGUgVGltZWFnb01vZHVsZVxuICAgKi9cbiAgc3RhdGljIGZvclJvb3QoY29uZmlnOiBUaW1lYWdvTW9kdWxlQ29uZmlnID0ge30pOiBNb2R1bGVXaXRoUHJvdmlkZXJzIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmdNb2R1bGU6IFRpbWVhZ29Nb2R1bGUsXG4gICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgY29uZmlnLmNsb2NrIHx8IHtwcm92aWRlOiBUaW1lYWdvQ2xvY2ssIHVzZUNsYXNzOiBUaW1lYWdvRGVmYXVsdENsb2NrfSxcbiAgICAgICAgY29uZmlnLmludGwgfHwgW10sXG4gICAgICAgIGNvbmZpZy5mb3JtYXR0ZXIgfHwge3Byb3ZpZGU6IFRpbWVhZ29Gb3JtYXR0ZXIsIHVzZUNsYXNzOiBUaW1lYWdvRGVmYXVsdEZvcm1hdHRlcn0sXG4gICAgICBdLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoaXMgbWV0aG9kIGluIHlvdXIgb3RoZXIgKG5vbiByb290KSBtb2R1bGVzIHRvIGltcG9ydCB0aGUgZGlyZWN0aXZlL3BpcGVcbiAgICovXG4gIHN0YXRpYyBmb3JDaGlsZChjb25maWc6IFRpbWVhZ29Nb2R1bGVDb25maWcgPSB7fSk6IE1vZHVsZVdpdGhQcm92aWRlcnMge1xuICAgIHJldHVybiB7XG4gICAgICBuZ01vZHVsZTogVGltZWFnb01vZHVsZSxcbiAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICBjb25maWcuY2xvY2sgfHwge3Byb3ZpZGU6IFRpbWVhZ29DbG9jaywgdXNlQ2xhc3M6IFRpbWVhZ29EZWZhdWx0Q2xvY2t9LFxuICAgICAgICBjb25maWcuaW50bCB8fCBbXSxcbiAgICAgICAgY29uZmlnLmZvcm1hdHRlciB8fCB7cHJvdmlkZTogVGltZWFnb0Zvcm1hdHRlciwgdXNlQ2xhc3M6IFRpbWVhZ29EZWZhdWx0Rm9ybWF0dGVyfSxcbiAgICAgIF0sXG4gICAgfTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbInRzbGliXzEuX19leHRlbmRzIiwib2YiLCJleHBhbmQiLCJ0aW1lciIsImVtcHR5Iiwic2tpcCIsIkluamVjdGFibGUiLCJTdWJqZWN0IiwiZmlsdGVyIiwiRGlyZWN0aXZlIiwiT3B0aW9uYWwiLCJDaGFuZ2VEZXRlY3RvclJlZiIsIkVsZW1lbnRSZWYiLCJJbnB1dCIsIlBpcGUiLCJOZ01vZHVsZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0lBQUE7Ozs7Ozs7Ozs7Ozs7O0lBY0E7SUFFQSxJQUFJLGFBQWEsR0FBRyxNQUFNLENBQUMsY0FBYztTQUNwQyxFQUFFLFNBQVMsRUFBRSxFQUFFLEVBQUUsWUFBWSxLQUFLLElBQUksVUFBVSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxTQUFTLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQztRQUM1RSxVQUFVLENBQUMsRUFBRSxDQUFDLElBQUksS0FBSyxJQUFJLENBQUMsSUFBSSxDQUFDO1lBQUUsSUFBSSxDQUFDLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQztnQkFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztBQUUvRSx1QkFBMEIs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